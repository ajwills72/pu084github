--- 
title: "The rapid synthesis of integral stimuli"
subtitle: "Supplementary Online Materials (peer reviewed)"
author: " "
date: " "
output:
  bookdown::pdf_document2:
    keep_tex: false
documentclass: article
linestretch: 2
geometry: "left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm"
csl: apa.csl
bibliography: [book.bib, packages.bib]
toc: false
link-citations: yes
---

```{r pkgs, echo=FALSE, warning=FALSE, message=FALSE}
### LOAD WORKSPACE FROM WHERE THE MAIN PAPER LEFT OFF
load("tmp/workspace.RData")

## Load packages
source("packages.R")

## Reinstate above to unmask authors
##author:
##  - Andy J. Wills, University of Plymouth, UK
##  - C.E.R. Edmunds, Queen Mary University of London, UK
##  - Fraser Milton, University of Exeter, UK
## date: "`r Sys.Date()`"
```

# Experiment 3 {-}

The purpose of the additional experiment reported in these supplementary materials was two-fold: 

1. To assess whether the stimuli as presented in the first two experiments meet a standard Garner definition of integral, i.e. the pairwise similarity ratings are better fit by a Euclidean than a city-block multidimensional scaling (MDS) solution [@garner1976interaction].

2. To assess the closeness of the resulting MDS solution to the solution provided by the Munsell color codes attributed to these stimuli. If differences are found, the MDS solution can be used in a re-analysis of the triad data that represents the stimuli in terms of a psychological, rather than physical, stimulus space.

## Method {-}

### Participants, apparatus and stimuli {-}

Twenty-four participants were tested in this experiment, using PsychoPy software [@pierce2007psychopy], version 1.83, to present the stimuli and to collect responses via a standard PC keyboard and mouse. The stimuli were the same as in the two main experiments.

### Procedure {-}

After some initial instructions explaining the task, and emphasizing accuracy over speed, the experiment began. On each trial, two square stimuli were shown in the center of the screen, arranged horizontally, and placed 2cm apart as measured from their centers. Participants were asked to rate the similarity of each pair of stimuli using a 1-9 scale. The scale was visually presented on the screen, below the square stimuli, along with text specifying that "1 = not very similar" and "9 = very similar". The number 5 was also indicated on the scale, but not further labelled. A moveable rectangular slider was present on this scale. Initially placed above the number 5, participants moved this slider to one of the nine available ratings, using the mouse, and indicated their response with a mouse click. The screen cleared immediately after the participant's response, and the next trial began one second later.

The experiment had two blocks of 56 trials. A block comprised two presentations of each possible pair of the eight stimuli, with left-right position of the stimulus pair counterbalanced across those two presentations. Trial ordering was randomized separately for each block and participant. 

## Results and discussion {-}

```{r dist-mat, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
## Load data
alldat  <- read_csv("data/ply84data.csv")

## Recode for stimulus pair, regardless of screen location, and as distance
alldat  <- alldat %>% rowwise() %>%
    mutate(low = min(lcol:rcol), high = max(lcol:rcol), dist = 10-sim)

## Average across all participants
avdat <- alldat %>% group_by(low, high) %>% summarize(dist = mean(dist))

## Create distance matrix
stims  <- 8
dm  <- array(0, dim = c(stims, stims))
for(rw in 1:nrow(avdat)) {
    one  <- avdat[rw,]
    dm[avdat$high[rw], avdat$low[rw]]  <- avdat$dist[rw]
}
show.sm  <- 10-dm # Archive matrix for report output
dm  <- as.dist(dm)
```

```{r sim-ply084, tidy=FALSE, echo=FALSE}
## This is a bit of a hack because kable can't deal with the 'dist'
## data type of distance matricies.
options(knitr.kable.NA = '')
show.sm[show.sm == 10]  <- NA
show.sm  <- show.sm[2:8,1:7]
colnames(show.sm)  <- 1:7
rownames(show.sm)  <- 2:8
knitr::kable(
           show.sm, row.names=TRUE, digits=2,
           caption = 'Pairwise similarity ratings.',
  booktabs = TRUE
)
```

```{r echo=FALSE, message=FALSE, results='hide'}
mds.model.city  <- isoMDS(dm, k = 2, p = 1)
mds.model  <- isoMDS(dm, k = 2, p = 2)
```

The average pairwise similarity ratings for the eight stimuli are shown in Table S\@ref(tab:sim-ply084). Two-dimensional, nonmetric multidimensional scaling [@kruskal1964nonmetric] was applied to these data, using the `isoMDS` function of the R package `MASS` [@R-MASS]. The stress of the Euclidean solution (`r round(mds.model$stress, 2)`) was lower than the city-block solution (`r round(mds.model.city$stress, 2)`), implying that these stimuli are better considered as integral than separable by Garner's operational definition. 

```{r echo=FALSE, message=FALSE, results='hide'}
munsell  <- read_csv("munsell-coords_red.csv")
munsell  <- munsell %>% mutate(chroma = chroma / 2) %>% select(chroma, bright)
cmp  <- procrustes(munsell, mds.model, truemean=TRUE)
```

Figure S\@ref(fig:ply084-mds) shows the Euclidean MDS solution, scaled and Procrustian rotated for best fit to the co-ordinates of the stimuli in the Munsell color system; these rigid transformations do not affect the distance relationships in the MDS solution. The `procrustes` function of the R package `vegan` [@R-vegan] was used for this part of the analysis. Following standard practice, we assumed that, in the Munsell system, two units of chroma are psychologically equivalent to one unit of brightness [@nickerson1936specification; @nosofsky1987attention; @shepard1958stimulus]. 

```{r ply084-mds, fig.cap="Multidimensional scaling solution", out.width='80%', fig.align='center', echo=FALSE}
rot  <- data.frame(fitted(cmp))
colnames(rot)  <- c("Chroma", "Brightness") 
rot  <- rot %>% add_column(.before=TRUE, Stimulus=1:8)

mds.plot  <-
    ggplot(rot, aes(x = Chroma, y = Brightness)) +
    geom_text(aes(label = Stimulus)) +
    xlab('Chroma / 2') +
    scale_x_continuous(limits = c(2,6), breaks=2:6) +
    scale_y_continuous(limits = c(1,7), breaks=1:7) +
    theme_bw()
mds.plot
```

Inspection of Figure S\@ref(fig:ply084-mds) indicates that, for six of the eight stimuli, the MDS solution shows similarity relations comparable to those in the Munsell co-ordinates. The exceptions are stimuli 2 and 4, which would appear to have been perceived as somewhat brighter and more saturated than their Munsell co-ordinates would indicate. This may have been a function of our use of commodity hardware for screen display. 

Given these moderate discrepancies between the Munsell co-ordinates and the multidimensional scaling solution, we re-analyzed the data from the previous two experiments, combining the two datasets and using the MDS co-ordinates as the inputs to our response models, rather than the Munsell co-ordinates. 

```{r ply084-model-init, echo=FALSE, message=FALSE, results='hide'}

## Derive model predictions for all 48 physical trial types

## We already have 'preds' from ply044, just need to modify
preds.84  <- preds %>% select(triad, left1, mid2, right3)

## We also have the coordinates, from the MDS solution. Just rename
coords.84  <- rot
colnames(coords.84)  <- c("stim", "sat", "bright")

## Add co-ordinates to preds
preds.84  <- preds.84 %>% rowwise() %>%
    mutate(L1.sat = coords.84$sat[left1]) %>%
    mutate(L1.bri = coords.84$bright[left1]) %>%
    mutate(M2.sat = coords.84$sat[mid2]) %>%
    mutate(M2.bri = coords.84$bright[mid2]) %>%
    mutate(R3.sat = coords.84$sat[right3]) %>%
    mutate(R3.bri = coords.84$bright[right3]) 

## Add model predictions, using functions defined in ply044
## Ident predictions will be broken due to no exact identities in MDS solution
## Insert zeros here so ID never makes a correct prediction by luck later

preds.84$os  <- NA
preds.84$bright  <- NA
preds.84$chroma  <- NA
preds.84$ident      <- 0

for(rw in 1:nrow(preds)) {
    preds.84$os[rw]  <- ooo(preds.84[rw, 5:10], 1, 1)
    preds.84$bright[rw]  <- ooo(preds.84[rw, 5:10], 0, 1)
    preds.84$chroma[rw]  <- ooo(preds.84[rw, 5:10], 1, 0)
}

## Load into array expected by fitting functions
cde <- preds.84 

```

```{r ply084-model-fit, echo=FALSE, message=FALSE, results='hide', cache=TRUE}
## Fit everyone we've tested against MDS co-ords
eda.ply44 <- eda.ply44 %>% add_column(exp = "ply044")
eda.ply62  <- eda.ply62 %>% add_column(exp = "ply062")
eda.ply84  <- bind_rows(eda.ply44, eda.ply62)
## (Thankfully subject numbers are unique across both experiments)

## Fit each response model to each participant, using all response blocks to do
## so.
bigdta  <- eda.ply84
ppts.ply84  <- c(as.numeric(ply044.N$subj), as.numeric(ply062.N$subj))
bigmod.ply84 <- array(0, dim=c(length(ppts.ply84),14))
bigmod.ply84 <- t(mapply(ppfits, ppts.ply84, 0)) ## This line does the model fits
colnames(bigmod.ply84) <- c("subj","cond","blk","bright", "chroma","ud",
                      "os", "ident", "resp1", "resp2", 
                      "resp3", "model", "consist","margin")

## Convert output to more informative labels
bigmf.ply84 <- as.data.frame(bigmod.ply84)
bigmf.ply84$model[bigmf.ply84$model > 3] <- 'Bias'
bigmf.ply84$model[bigmf.ply84$model == 1] <- 'UD'
bigmf.ply84$model[bigmf.ply84$model == 2] <- 'OS'
bigmf.ply84$model[bigmf.ply84$model == 3] <- 'ID'
bigmf.ply84$cond[bigmf.ply84$cond==1] <- '100 ms'
bigmf.ply84$cond[bigmf.ply84$cond==2] <- '2000 ms'
```

```{r ply084-model-block, echo=FALSE, message=FALSE, results='hide', cache=TRUE}
exclude.84 <- bigmf.ply84 %>% filter(model == "Bias") %>% select(subj)

## Fit each response model to each block of each participant, using all response blocks to do
## so.
bigdta  <- eda.ply84
bigdta <- bigdta %>% filter(!(subj %in% exclude.84)) # Exclude bias ppts
ppts.blk.ply84 <- levels(as.factor(bigdta$subj))
bigmodblk.ply84 <- t(mapply(ppfits,rep(ppts.blk.ply84, each=12),1:12)) # Fit to each block
colnames(bigmodblk.ply84) <-colnames(bigmod.ply84)

# Convert to more informative labels
bigmfblk.ply84 <- as.data.frame(bigmodblk.ply84)
bigmfblk.ply84$model[bigmfblk.ply84$model == 1] <- 'UD'
bigmfblk.ply84$model[bigmfblk.ply84$model == 2] <- 'OS'
bigmfblk.ply84$model[bigmfblk.ply84$model == 3] <- 'ID'
bigmfblk.ply84$cond[bigmfblk.ply84$cond==1] <- '100 ms'
bigmfblk.ply84$cond[bigmfblk.ply84$cond==2] <- '2000 ms'

## Remove response bias fit columns - these analyses were not conducted.
bigmfblk.ply84  <- bigmfblk.ply84 %>% select(-resp1, -resp2, -resp3)
```

```{r ply84-block-report, echo=FALSE, message=FALSE}
## Figures for reporting
N.ties.ply84  <- bigmfblk.ply84 %>% filter(margin == 0) %>% summarise(N= n())
N.ppts.ply84  <- length(unique(bigmfblk.ply84$subj))
N.blks.ply84  <- length(unique(bigmfblk.ply84$blk))

## Remove tied blocks
bigmfblk.ply84  <- bigmfblk.ply84 %>% filter(margin > 0)

## Aggregate for analysis

## Count model wins
blk.sum.ply84  <- as.data.frame(table(bigmfblk.ply84$subj, bigmfblk.ply84$model))
colnames(blk.sum.ply84)  <- c("subj", "Model", "Freq")
blk.sum.ply84  <- blk.sum.ply84 %>% pivot_wider(names_from=Model, values_from=Freq)

## Bind condition data back into frame
conds.ply84  <- bigmfblk.ply84 %>% select(subj, cond) %>% distinct
conds.ply84$subj  <- as.factor(conds.ply84$subj)
blk.sum.ply84  <- right_join(conds.ply84, blk.sum.ply84)

## Calculate proportions (note: some missing blocks due to ties)
## (note 2: ID will never win in this analysis)
blk.sum.ply84  <- blk.sum.ply84 %>% mutate(total = UD+OS)
blk.sum.ply84  <- blk.sum.ply84 %>% mutate(ID.p = 0, OS.p = OS/total, UD.p = UD/total)

blk.report.ply84  <- blk.sum.ply84 %>% group_by(cond) %>%
    summarise(UD = mean(UD.p),
              OS = mean(OS.p),
              ID = mean(ID.p)) 

## Produce table for report
colnames(blk.report.ply84)  <-  c("Time", "UD", "OS", "ID")

knitr::kable(
           blk.report.ply84, row.names=FALSE, digits=3,
           caption = 'Mean proportion of unidimensional (UD), overall similarity (OS), and identity (ID) blocks, as a function of stimulus presentation time.',
           booktabs = TRUE
       )

## Bayesian analysis without prior, as both experiments combined
ud.bf.ply84  <- ttestBF(formula = UD.p ~ cond, data = data.frame(blk.sum.ply84))
ud.bf.val.ply84  <- round(extractBF(ud.bf.ply84)$bf, 0)

```

`r toTitleCase(n2w(nrow(exclude.84)))` participants were excluded due to being best fit by a response-bias model. On `r round(N.ties.ply84*100/(N.ppts.ply84*N.blks.ply84),0)`% of blocks, models tied for first place; these blocks were removed from further analysis. Table S\@ref(tab:ply84-block-report) shows the results of
our re-analysis. Using the MDS co-ordinates for these stimuli approximately doubled the magnitude of the effect observed with the Munsell co-ordinates; unidimensional responding rose from 9% at 2000 ms to 32% at 100 ms. Bayesian analysis, employing a non-informative prior, provides very strong support for an effect of time pressure on the prevalence of unidimensional responding, _BF_ = `r ud.bf.val.ply84`. Hence, overall, the three experiments presented in the current paper provide strong evidence for the effect predicted by Combination Theory, and disconfirm Differentiation Theory.

Further inspection of Figure S\@ref(fig:ply084-mds) reveals that no stimulus is identically placed on either dimension (this is true even for stimuli 2 and 4 on the chroma dimension). As a consequence, the Identity response model can never predict partcipants' responses, leading to reported zero prevalence of Identity responding in Table S\@ref(tab:ply84-block-report). It would in principle be possible to generalize the Identity response model such that it could deal with near-identity (such as stimuli 2 and 4 on chroma) effectively, and the work of @smith1989model suggests a way in which this could be done. However, given the very low prevalence of ID classification observed for these stimuli in our earlier analysis, where the use of Munsell co-ordinates would have made such responding detectable if it had occurred, such a generalization of the Identity model would be unlikely to change the conclusions of the current work. 

# References {-}

```{r include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(.packages(), 'packages.bib')
```
